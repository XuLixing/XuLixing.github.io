<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/04/03/Verilog_Learning/Verilog_chapter_3/Verilog_chapter_3/</url>
    <content><![CDATA[<h1 id="Chapter-3-程序设计语句和描述方式"><a href="#Chapter-3-程序设计语句和描述方式" class="headerlink" title="Chapter 3 程序设计语句和描述方式"></a>Chapter 3 程序设计语句和描述方式</h1><hr>
<h3 id="3-1-数据流建模"><a href="#3-1-数据流建模" class="headerlink" title="3.1 数据流建模"></a>3.1 数据流建模</h3><h3 id="3-11-连续赋值语句"><a href="#3-11-连续赋值语句" class="headerlink" title="3.11 连续赋值语句"></a>3.11 连续赋值语句</h3><ul>
<li>标量，如wire a,b;</li>
<li>向量，如wire [3:0] a, b;</li>
</ul>
<p>Note：</p>
<blockquote>
<ol>
<li>Assign 类型 需要用 ‘=’</li>
<li>变量需要wire类型  </li>
<li>并行计算，没有顺序</li>
</ol>
</blockquote>
<h3 id="3-2-行为级建模"><a href="#3-2-行为级建模" class="headerlink" title="3.2 行为级建模"></a>3.2 行为级建模</h3><h3 id="3-2-1-过程语句"><a href="#3-2-1-过程语句" class="headerlink" title="3.2.1 过程语句"></a>3.2.1 过程语句</h3><p>A）initial 过程语句</p>
<p>initial 下顺序赋值，添加<code>[#100]</code>等表达式可以增加延迟。</p>
<p>格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">* initial</span><br><span class="line">	begin</span><br><span class="line">	</span><br><span class="line">	end</span><br></pre></td></tr></table></figure></div>

<p>B）always 过程语句:</p>
<p>always @(敏感列表)</p>
<p>code example：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">always @( )</span><br><span class="line"></span><br><span class="line">    case()</span><br><span class="line"></span><br><span class="line">    endcase</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">always @( )</span><br><span class="line"></span><br><span class="line">    begin</span><br><span class="line"></span><br><span class="line">    end</span><br></pre></td></tr></table></figure></div>
<p>Note:</p>
<blockquote>
<ol>
<li>在过程语句（initial 和 always）中，被赋值信号必须被定义为 reg 型。</li>
<li>采用过程对组合逻辑电路进行描述时：全部输入信号需要列入敏感列表。</li>
<li>采用过程对时序逻辑电路进行描述时：需要把时间信号和部分输入信号列入。</li>
</ol>
</blockquote>
<h3 id="3-2-2-语句块"><a href="#3-2-2-语句块" class="headerlink" title="3.2.2 语句块"></a>3.2.2 语句块</h3><p>A）begin-end：语句内部按照顺序执行，可以用于可综合电路程序和仿真测试程序。</p>
<p>B)  fork-join: 语句内部按照按照并行方式，不可以用于可综合电路，只能用于仿真程序测试。</p>
<p>比较：<br><a href="">1.比较</a></p>
<p>###3.2.3 过程赋值语句</p>
<p><em>阻塞赋值语句和非阻塞赋值语句</em></p>
<ul>
<li>阻塞赋值语句“=” 有如下特点：<ol>
<li>串行语句块中，各条阻塞赋值语句将按照先后排列顺序一次执行。<br>并行语句块中，各条阻塞赋值语句同时执行，没有顺序</li>
<li>执行阻塞赋值语句的顺序是：先计算等号右端的表达式，然后立刻赋值给左边的变量，没有延时。</li>
</ol>
</li>
<li>非阻塞赋值语句“&lt;=” 有如下特点：<ol>
<li>串行语句块，各条非阻塞赋值语句的执行没有先后顺序之分。前面的语句不会影响后边语句的执行。各条语句并行执行。</li>
<li>执行非阻塞赋值语句的顺序是，先计算右端表达式的值，然后等到延时时间结束，再将计算的值付给左边的变量。</li>
</ol>
</li>
</ul>
<p>Note:<br>    需要掌握，阻塞和非阻塞电路对应verilog程序综合的电路的情况。<br>    <a href="">阻塞非阻塞</a></p>
<p>###3.2.4 过程连续赋值语句<br>过程性连续赋值语句有两种类型：赋值，重新赋值( assign, deasign) 和 强制、释放（force，release）</p>
<h3 id="3-2-5-条件分支语句"><a href="#3-2-5-条件分支语句" class="headerlink" title="3.2.5 条件分支语句"></a>3.2.5 条件分支语句</h3><p>Verilog HDL的条件分支语句有两种，If条件语句和case条件分支语句</p>
<ol>
<li>if - else</li>
<li>case  条件分支。<br>容易实现多路分支选择控制的语句，更加直观和方便。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">case</span><br><span class="line">0 : </span><br><span class="line">1 :</span><br><span class="line">...: &#x2F;&#x2F; 穷尽每一种情况</span><br><span class="line">default: </span><br><span class="line">endcase</span><br></pre></td></tr></table></figure></div>
<p>Note : 使用case语句时，case应该包含所有的状态，如果没有包含全，则缺少项回产生锁存器！！！ 这是不允许的在同步时许电路设计中。</p>
<h3 id="3-2-6-循环语句"><a href="#3-2-6-循环语句" class="headerlink" title="3.2.6 循环语句"></a>3.2.6 循环语句</h3><ol>
<li><p>forever<br>永久循环。在永久循环内不包含任何条件表达式，只执行无限的循环，指导遇到系统任务¥finish为止。如果需要从forever循环汇总推出，则可以使用disable语句。<br><a href="">forever</a></p>
</li>
<li><p>repeat<br>所引导的循环语句执行固定次数的循环。<br><a href="">repeat</a></p>
</li>
<li><p>while<br>仅有在while （） 括号内表达式为真才执行。<br><a href="">while</a></p>
</li>
<li><p>for<br><a href="">for</a></p>
</li>
</ol>
<h3 id="3-3-结构化建模"><a href="#3-3-结构化建模" class="headerlink" title="3.3 结构化建模"></a>3.3 结构化建模</h3><h4 id="3-3-1-模块级建模"><a href="#3-3-1-模块级建模" class="headerlink" title="3.3.1 模块级建模"></a>3.3.1 模块级建模</h4><ol>
<li><p>模块调用方式<br>在Verilog HDL中，模块可以被任何模块调用，这种调用实际上是将模块所描述的电路复制并连接。模块调用的基本语法格式是：<br>模块名 &lt;参数值列表&gt; 实例名 （端口名列表）：<br><a href="">实例化</a></p>
<p> Note：</p>
<p> A. 在同一个模块中当前模块被调用了几次，则需要用不同的实例名加以标明。</p>
<p> B. 当需要多次调用，可以采用 阵列调用的方式对模块进行调用。<br> （下面例子是对应位相与）</p>
</li>
</ol>
<p>  <a href="">实例化2</a></p>
<ol start="2">
<li>模块端口对应方式</li>
</ol>
<ul>
<li><p>端口位置对应方式：调用时，端口一定要严格按照端口定义顺序。</p>
</li>
<li><p>端口名对应方式：</p>
<p>  <a href="">实例化3</a></p>
<p>   .clk(clock), （）内是模块定义的变量，clk是调用模块的变量。</p>
</li>
<li><p>不同端口位宽的匹配：从低位开始取。</p>
</li>
</ul>
<ol start="3">
<li> 模块参考值<br>有两种途径可以改变模块实例的参考值，分别是使用带有参数的模块实例语句修改参数值和使用定义参数语句（defparam）</li>
</ol>
<p>3.3.2 门级建模</p>
<p>3.3.3 开关级建模</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/02/Verilog_Learning/Verilog_chapter_1&amp;2/verilog_chapter_1&amp;2/</url>
    <content><![CDATA[<h1 id="Verilog-Learning-Chapter-1-amp-2"><a href="#Verilog-Learning-Chapter-1-amp-2" class="headerlink" title="Verilog Learning Chapter 1&amp;2"></a>Verilog Learning Chapter 1&amp;2</h1><hr>
<p>In this chapter, we would focus on fundamentals and core concepts of Verilog HDL. 在这一章中，主要介绍一些概念和Verlog HDL的基础知识。</p>
<h3 id="0-模块概念："><a href="#0-模块概念：" class="headerlink" title="0.模块概念："></a>0.模块概念：</h3><ul>
<li><p>软核 Soft core:<br>  一般指经过功能验证，可综合的Verilog HDL（VHDL）模型.</p>
</li>
<li><p>固核 Firm core:<br>  通知指在ASIC or FPGA 器件上，经过综合验证的电路网表文件。</p>
</li>
<li><p>硬核 Hard core:<br>  在ASIC器件上，经过验证正确的的电路结构版图掩膜。</p>
</li>
</ul>
<h3 id="1-Verilog-HDL-基础"><a href="#1-Verilog-HDL-基础" class="headerlink" title="1.Verilog HDL 基础"></a>1.Verilog HDL 基础</h3><ul>
<li>数值状态</li>
</ul>
<p><a href="https://github.com/XuLixing/Note/raw/main/images">vaule_conditions</a></p>
<ul>
<li>位制：二进制 b； 八进制: o；十进制：d；十六进制：h</li>
<li>整数表示 8‘b0000_0001。 位数‘位制‘数字</li>
</ul>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><ul>
<li>分类：wire（tri三态门，tri0下拉电阻，tri1上拉电阻），reg，RAM</li>
<li>reg：对应硬件电路元件具有状态保持作用；触发器，锁存器</li>
<li>RAM：类似于二维数组的定义方式。 reg[7:0] mem1[255:0] //定义256个8位寄存器的mem。</li>
</ul>
<p>抽象数据类型：</p>
<ul>
<li>整型 integer，时间 time，实型 real ，参数型parameter.</li>
<li>integer index //定义32位有符号数</li>
<li>time a; // 定义两个64位的时间型变量。<br>主要用于对模拟时间的存储和计算处理，常与$time 一起使用</li>
<li>real stime; // 定义一个实数型数据（浮点型），常用于延迟时间的计算</li>
<li>parameter length=32, // 常量，在仿真之前就被复制，提高程序可读性。</li>
</ul>
<p>运算符：<br><a href="">opeartors</a></p>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a><em>Note</em>:</h4><p>赋值语句下，结果的长度是由操作左端目标长度决定。取低N位，不够补0。</p>
<h3 id="3-条件运算符"><a href="#3-条件运算符" class="headerlink" title="3. 条件运算符"></a>3. 条件运算符</h3><p>example: (!sel)?in1:in2;</p>
<h3 id="4-连接和复制运算符"><a href="#4-连接和复制运算符" class="headerlink" title="4. 连接和复制运算符"></a>4. 连接和复制运算符</h3><p><a href="">连接</a></p>
<h3 id="5-模块的基本概念"><a href="#5-模块的基本概念" class="headerlink" title="5. 模块的基本概念"></a>5. 模块的基本概念</h3><p>Module是verilog HDL的基本单元</p>
<blockquote>
<p>组成：</p>
</blockquote>
<ul>
<li>开始：NAME module；- endmodule</li>
<li>端口定义：input output （模块引用具体）</li>
<li>数据类型定义： wire，reg，memory，parameter</li>
<li>逻辑功能描述：initial，always，assign，function，task</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ASIC Design Flow</title>
    <url>/2021/03/29/fisrt-blog/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><p>ASIC设计流程</p>
<h2 id="Design-Flow：-基于Synopsys"><a href="#Design-Flow：-基于Synopsys" class="headerlink" title="Design Flow：(基于Synopsys)"></a>Design Flow：(基于Synopsys)</h2><ol>
<li>将已经在 FPGA 上验证过的代码(Verilog)修改为不依赖于 FPGA 资源 的 RTL 代码。</li>
<li>使用 VCS 对 RTL 代码进行输入输出关系仿真，进行功能验证。</li>
<li>使用 Design Compiler(DC)对 RTL 代码进行逻辑综合，获得 DC 网<br>表。</li>
<li>使用 Formality 对 RTL 代码和 DC 网表进行形式验证，验证两者的结构 一致性。</li>
<li>使用 VCS 对 DC 网表进行输入输出关系仿真，对比 RTL 仿真的结果， 验证两者的功能一致性。</li>
<li>使用 IC Compiler(ICC)对 DC 网表进行物理综合，获得 ICC 网表和 版图。</li>
<li>使用 Calibre 对版图进行设计天线规则检查，规则检查(DRC)和原理 图版图一致性检查(LVS)。</li>
<li>使用 Formality 对 DC 网表和 ICC 网表进行形式验证，验证两者的结构 一致性。</li>
<li>使用 StarRC 对版图进行电容电阻参数提取，获得 RC 参数，进一步获 得各网线的延迟信息。此将此延迟信息并反标至 ICC 网表。</li>
<li>使用 PrimeTime 对反标后的 ICC 网表进行时序分析，并导出 sdf 延时文 件用于 VCS 后仿。</li>
<li>使用 VCS 对反标后的 ICC 网表进行输入输出关系仿真，对比 RTL 仿真 的结果，验证两者的功能一致性。</li>
<li>获得 GDSII 文档。</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>second</p>
<p>third</p>
<p>ending </p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$#include</span>&lt;stdio.h&gt;</span><br><span class="line">int <span class="function"><span class="title">main</span></span> ()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello Macbook pro\n&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
