<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Introduction to My Blog</title>
    <url>/2021/04/13/Blog_Inro/</url>
    <content><![CDATA[<p>This is my blog, built at March, 2021, supported by Github &amp; Hexo &amp; NexT Theme.</p>
<p>Accumulation does matter.</p>
<p>This blog would serve as window, where I could share my my points, output fantastic ideas and trace any change inside my mind.</p>
<p>For Now, I would focus more on producing notes and posts from my leanrning, as many as possible.</p>
<p>I hope that what i will write or i have wrriten would make a difference to the world.</p>
]]></content>
  </entry>
  <entry>
    <title>Clock Domain Crossing (CDC) Part 1</title>
    <url>/2021/05/29/CDC/CDC_1/</url>
    <content><![CDATA[<p>Reference：</p>
<ol>
<li><p>《The Study of Synchronizer Design in Asynchronous Clock Domain System》-蒲田</p>
</li>
<li><p>《Clock Domain Crossing (CDC) Design &amp; Verification Techniques Using SystemVerilog》-Clifford E. Cummings</p>
</li>
</ol>
<h3 id="1-Metastability"><a href="#1-Metastability" class="headerlink" title="1. Metastability:"></a>1. Metastability:</h3><p>亚稳态指信号在一段时间内不再稳定在0或者1，原因在于存储元件并非理想元件，对于寄存器信号需要在时钟边沿前后保持不变（setup&amp;holding约束），否则可能产生不稳定的输出。在多时钟域设计中，亚稳态不能被避免但有害效应可以被中和抵消。</p>
<h4 id="1-1-Synchronization-failure"><a href="#1-1-Synchronization-failure" class="headerlink" title="1.1 Synchronization failure"></a>1.1 Synchronization failure</h4><p>下图展示两级FF，但是两级的CLK不同步，第二级FF在第一级输出未达到稳定时进行了采样，产生synchronization failure. 如下图，采样信号无法在bclk的下一个上升沿保持稳定，亚稳态会被传递。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/CDC/CDC_1/1.png" alt="同步错误"></p>
<p>“When sampling a changing data signal with a clock … the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs.”</p>
<h4 id="1-2-Consideration"><a href="#1-2-Consideration" class="headerlink" title="1.2 Consideration"></a>1.2 Consideration</h4><p>每一级的FF都要一个具体的setup time 和 hold time，即要求input的数据在clock 上升沿前保持一段时间（setup）和之后保持一段时间（hold）。对于一个具体的设计而言，这个时间窗口（亚稳态窗口）可以视为一个design parameter，当这个时间窗口输入数据发生变化，输出就可能产生亚稳态。</p>
<h4 id="1-3-MTBF-Mean-Time-Before-Failure"><a href="#1-3-MTBF-Mean-Time-Before-Failure" class="headerlink" title="1.3 MTBF (Mean Time Before Failure)"></a>1.3 MTBF (Mean Time Before Failure)</h4><p>对于大多数应用，尤其是跨时钟域计算MTBF（Mean Time Before Failure）非常重要。Failure指的是信号通过通过一个同步寄存器进入亚稳态，持续保持亚稳态直到被下一级寄存器采样。MTBF表示两个failure之间的时间（希望大到几天，几年）。</p>
<p>MTBF表示触发器采样失败的时间间隔。MTBF的计算公式如下：MTBF的数值越大越好；大MTBF表明潜在失效发生在更长的时间范围内；小的MTBF表明亚稳态更可能发生。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/CDC/CDC_1/2.png" alt="MTBF相关"></p>
<p>定量计算公式如下：<br><img src="https://github.com/XuLixing/blog_images/raw/main/CDC/CDC_1/3.png" alt="MTBF定量计算公式"><br>其中：</p>
<ul>
<li>tr = 分辨时间（时钟沿开始）// resolution time (start from clk edge)</li>
<li>𝜏,𝑇0 = 触发器参数 // parameters releated to FF</li>
<li>𝑓 = 采样时钟频率 // sampling frequency</li>
<li>a = 异步事件触发频率 <a href="//asynchronous">//</a> asynchronized events activated frequency</li>
</ul>
<p>对于一个典型的 0.25µm 工艺的 ASIC 库中的一个触发器，我们取如下的参数：tr = 2.3ns, τ = 0.31ns, T0 = 9.6as, f=100MHZ, a = 10MHZ, MTBF = <strong>2.01 days</strong></p>
<h4 id="1-4-Approaches-to-reduce-metastability-减少亚稳态的方法"><a href="#1-4-Approaches-to-reduce-metastability-减少亚稳态的方法" class="headerlink" title="1.4 Approaches to reduce metastability 减少亚稳态的方法"></a>1.4 Approaches to reduce metastability 减少亚稳态的方法</h4><p>减少亚稳态的方法有以下几种</p>
<ol>
<li><p>使用同步器：也就是我们常用的2级或者多级FF打拍的方法;同步器后面会专门论述；</p>
</li>
<li><p>降低频率：如果能满足功能要求，那么降低频率能够减少亚稳态的产生;</p>
</li>
<li><p>避免变化过快或者过于频繁的信号进行跨时钟采样</p>
</li>
<li><p>采用更快的触发器：更快的触发器，也可以减少亚稳态的产生。</p>
</li>
</ol>
<h3 id="2-Synchronizers"><a href="#2-Synchronizers" class="headerlink" title="2. Synchronizers"></a>2. Synchronizers</h3><p>当信号跨时钟域时候，最容易忽视的一个问题是，这个信号需要每个时钟都被采样，不能漏掉每一个值吗？这是新手最容易忽视的一个问题。当考虑到信号穿过CDC边界时，</p>
<p>我们考虑两种情况：</p>
<ul>
<li>有一些信号不需要sample 可以miss </li>
</ul>
<p>// some signals are not required to be sampled and could be missed.</p>
<ul>
<li>每一个信号都需要被sample 并且跨CDC </li>
</ul>
<p>// every signals are required to be sampled.</p>
<p>在这两种情况下：CDC信号都需要某种形式的同步在接收时钟域内<br>In both of these scenarios, the CDC signals will require some form of <strong>synchronization</strong> into the receiving clock domain.</p>
<p>同步器：是采样一个异步时钟信号，并将其过渡成与一个在本地或者采样时钟的输出信号。“A synchronizer is a device that samples an asynchronous signal and outputs a version of the signal that has transitions synchronized to a local or sample clock”</p>
<h4 id="2-1-Two-flip-flop-synchronizer"><a href="#2-1-Two-flip-flop-synchronizer" class="headerlink" title="2.1 Two flip-flop synchronizer"></a>2.1 Two flip-flop synchronizer</h4><p>最简单和最常用的同步器，是两级FF同步器.</p>
<p>第一级FF采样一个异步信号，极端情况（采样一个变化信号）则第一级FF输出为亚稳态；保持一个时钟周期（亚稳态recover），信号被重新采样为有效的输出。</p>
<p>Note：双寄存器并不能消除亚稳态，它只是减少出现亚稳态的概率，减少到一个可以几乎忽略不计的程度。<br><img src="https://github.com/XuLixing/blog_images/raw/main/CDC/CDC_1/4.png" alt="两级同步器"></p>
<p>在这个过程，需要保证的这个保持时间，否则会产生synchronization failure。 这个时间与输入信号的频率和同步FF的频率有关。这个时间为MTBF。</p>
<p>对于大多数同步应用，两级FF同步器已经足够移除所有亚稳态。</p>
<h4 id="2-3-Three-flip-flop-synchronizer"><a href="#2-3-Three-flip-flop-synchronizer" class="headerlink" title="2.3 Three flip-flop synchronizer"></a>2.3 Three flip-flop synchronizer</h4><p>对于一些极其高速的应用，MTBF在两级同步器之间太短。因此可以添加第三级FF以增加MTBF到一个满意的时间范围。<br><img src="https://github.com/XuLixing/blog_images/raw/main/CDC/CDC_1/5.png" alt="三级同步器"></p>
]]></content>
      <categories>
        <category>VLSI</category>
        <category>CDC</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>CDC</tag>
      </tags>
  </entry>
  <entry>
    <title>Efficient FSM coding in verilog</title>
    <url>/2021/04/05/FSM_coding/Notes_FSM_coding/</url>
    <content><![CDATA[<p>Learning Source:《The Fundamentals of Efficient Synthesizable Finite State Machine Design using NC-Verilog and BuildGates》</p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract:"></a>Abstract:</h3><ol>
<li>Important techniques related to one and two always block styles to code FSMs with combinational outputs are given to show why using a two always block style is preferred. </li>
<li>An efficient Verilog-unique onehot FSM coding style is also shown. </li>
<li>Reasons and techniques for registering FSM outputs are also detailed.</li>
</ol>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction:"></a>1. Introduction:</h3><h4 id="Note-利用Always语句编写组合逻辑电路和时序逻辑电路。"><a href="#Note-利用Always语句编写组合逻辑电路和时序逻辑电路。" class="headerlink" title="Note: 利用Always语句编写组合逻辑电路和时序逻辑电路。"></a>Note: 利用Always语句编写组合逻辑电路和时序逻辑电路。</h4><ol>
<li><p>组合逻辑电路的always block编写严格（阻塞赋值），敏感列表内没有posedge or negedge这些verilog keyword！</p>
<blockquote>
<p>Combinational always blocks are always blocks that are used to code combinational logic functionality and are strictly coded using blocking assignments。</p>
</blockquote>
</li>
<li><p>时序电路always block（非阻塞赋值），有edge-based sensitivity list。</p>
</li>
</ol>
<h3 id="2-Mearly-and-moore-FSM"><a href="#2-Mearly-and-moore-FSM" class="headerlink" title="2. Mearly and moore FSM"></a>2. Mearly and moore FSM</h3><p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/1.%20FSM%E7%B1%BB%E5%9E%8B.png" alt="Figure 1.FSM_type"></p>
<h3 id="3-Binary-or-Onehot-Encoded"><a href="#3-Binary-or-Onehot-Encoded" class="headerlink" title="3. Binary or Onehot Encoded?"></a>3. Binary or Onehot Encoded?</h3><ul>
<li><p>Binary-encode FSM 需要的位宽（FF的数量）仅是需要状态的log2（#states）</p>
<p>  优点：使用触发器的个数较少，节省资源。<br>  缺点：状态跳转时可能有多个bit错误，引起毛刺，造成逻辑错误。</p>
</li>
<li><p>One-hot encode FSM 需要的位宽（FF的数量）为需要的状态的数量。</p>
<p>  缺点：增加了触发器个数，寄存器资源利用效率低。<br>  优点：但是方便译码，有效化简组合逻辑电路</p>
</li>
</ul>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/2.%20code%20style.png" alt="Figure 2.编码方式"></p>
<p>Notes：</p>
<ol>
<li><p>FPGA推荐使用one-hot编码因为其内置有足够数量的FF，使用one-hot编码可以节省复杂的译码组合逻辑电路设计。</p>
<blockquote>
<p>FPGA vendors frequently recommend using a onehot state encoding style because flip-flops are plentiful in an FPGA and the combinational logic required to implement a onehot FSM design is typically smaller than most binary encoding styles.</p>
</blockquote>
</li>
<li><p>FPGA的性能与FPGA中组合逻辑电路的size的决定。实现同样的功能，onehot码的用到的组合逻辑电路面积更小，可以run faster。</p>
<blockquote>
<p>Since FPGA performance is typically related to the combinational logic size of the FPGA design, onehot FSMs typically run faster than a binary encoded FSM with larger combinational logic blocks</p>
</blockquote>
</li>
</ol>
<h3 id="4-FSM-Coding-Goals："><a href="#4-FSM-Coding-Goals：" class="headerlink" title="4. FSM Coding Goals："></a>4. FSM Coding Goals：</h3><ul>
<li>The FSM coding style should be easily modified to change state encodings and FSM styles.</li>
<li>The coding style should be compact.</li>
<li>The coding style should be easy to code and understand.</li>
<li>The coding style should facilitate debugging.</li>
<li>The coding style should yield efficient synthesis results.</li>
</ul>
<h3 id="5-Two-Always-Block-FSM-style-Good"><a href="#5-Two-Always-Block-FSM-style-Good" class="headerlink" title="5. Two Always Block FSM style (Good)"></a>5. Two Always Block FSM style (Good)</h3><h4 id="5-1-Exapmle-Code"><a href="#5-1-Exapmle-Code" class="headerlink" title="5.1 Exapmle_Code"></a>5.1 Exapmle_Code</h4><p>用两个always block编写，一个写时序逻辑，一个写组合逻辑。</p>
<p>Note：</p>
<ol>
<li>时序always block定义时序电路（状态转移），非阻塞赋值。</li>
<li>组合always block定义组合逻辑电路，敏感列表为输入，没有时钟clk和复位信号，使用阻塞赋值。</li>
</ol>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/3.4states_FSM.png" alt="Figure 3.Four-states FSM"></p>
<p>Important notes:</p>
<ol>
<li><p>Parameter 定义state类型（binary还是onehot）和名称（state的名字）：方便修改，如果需要换coding style的话就只需要更改parameter的定义就行。</p>
</li>
<li><p>在输出赋值之后，再给state or next state赋值。</p>
<blockquote>
<p>Declarations are made for state and next (next state) after the parameter assignments.</p>
</blockquote>
</li>
<li><p>时序逻辑用非阻塞赋值。</p>
<blockquote>
<p>The sequential always block is coded using nonblocking assignments.</p>
</blockquote>
</li>
<li><p>组合逻辑电路的敏感列表有state，所有组合逻辑input变量。</p>
</li>
<li><p>组合逻辑电路always block中用阻塞赋值。</p>
</li>
<li><p><strong>The combinational always block has a default next state assignment at the top of the always block</strong></p>
</li>
<li><p>输出在case语句前被赋初值（default value）。优点在于：</p>
<p> A. case语句之后不需要再写default的情况，电路上消除了产生锁存器的可能。<br> B. 每一个case中只在输出变化赋新的值。从代码上，更容易观察到输出的变化，代码可读性增加。</p>
<blockquote>
<p>Default output assignments are made before coding the <strong>case</strong> statement (this eliminates latches and reduces the amount of code required to code the rest of the outputs in the <strong>case</strong> statement and highlights in the <strong>case</strong> statement exactly in which states the individual output(s) change)</p>
</blockquote>
</li>
<li><p>组合逻辑always block内的if-else 语句数量和 状态转移图STD的转移弧线数量一致。（输入的 !rst不算）</p>
<blockquote>
<p>The number of transition arcs between states in the FSM state diagram should equal the number of <strong>if</strong>-<strong>else</strong>-type statements in the combinational always block.</p>
</blockquote>
</li>
<li><p>方便查看，next的赋值都放在同一列。</p>
</li>
</ol>
<h4 id="5-2-Fear-of-transitions-to-erroneous-states"><a href="#5-2-Fear-of-transitions-to-erroneous-states" class="headerlink" title="5.2 Fear of transitions to erroneous states"></a>5.2 Fear of transitions to erroneous states</h4><p>一般来说，不会发生。</p>
<p>在一些极端情况下，系统要求更高的robertness：如alpha粒子，高能粒子等。系统的状态可能进入到一个错误状态！但是让state/next state寄存器回到想要的状态并不够！这是因为可能，剩下部分的硬件已经进入变化后的state的状态。</p>
<p>Possible bad situation：系统可能因此进入一个lockup状态，因为硬件正在等待一个不可能到来的状态转移信号。（如系统在启动后，由于高能粒子轰击，刚好回到启动state，但是外界不会再给启动的激励，因而系统会卡在此状态不动）</p>
<p>解决办法：需要一种设计，当state寄存器进入到错误状态时：不仅下一个时刻，state能自动回到正常状态，剩下的状态也会在下一个状态过渡时候reset！</p>
<h4 id="5-3-Making-default-next-equal-all-X’s-assignment"><a href="#5-3-Making-default-next-equal-all-X’s-assignment" class="headerlink" title="5.3 Making default next equal all X’s assignment"></a>5.3 Making default next equal all X’s assignment</h4><p>在组合逻辑always敏感列表后，直接对next进行赋初值X‘s，next会在之后的case中被赋初值。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/3.4states_FSM.png" alt="Figure 4.Four-states FSM"></p>
<p>如果我们给全X给next，如果某一状态转移可能没有在case语句中被描述到，state的预综合仿真模型会产生一个未知的输出的状态。这是一个有效debug FSM设计的方法。X在综合工具里认为是don’t care. </p>
<blockquote>
<p>By making a default next state assignment of X’s, pre-synthesis simulation models will cause the state machine outputs to go unknown if not all state transitions have been explicitly assigned in the case statement. This is a useful technique to debug state machine designs, plus the X’s will be treated as “don’t cares” by the synthesis tool.</p>
</blockquote>
<p><strong>不理解的问题：如果组合逻辑过于复杂？？？？如pcpu</strong></p>
<h3 id="6-One-Always-Block-FSM-style-Avoid"><a href="#6-One-Always-Block-FSM-style-Avoid" class="headerlink" title="6 One Always Block FSM style (Avoid)"></a>6 One Always Block FSM style (Avoid)</h3><h3 id="7-Onehot-FSM-Coding-style-Good-style"><a href="#7-Onehot-FSM-Coding-style-Good-style" class="headerlink" title="7 Onehot FSM Coding style. (Good style)"></a>7 Onehot FSM Coding style. (Good style)</h3><p>Onehot 编码与二进制编码的核心在于parameter不再代表state encoding，而是用来表示state向量的index。case的语句的比较则简化成单个bit的比较。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/4.%20onehot_coding.png" alt="Figure 5.Onehot FSM"></p>
<p>Onehot 编码与二进制编码的核心在于parameter不再代表state encoding，而是用来表示state向量的index。case的语句的比较则简化成单个bit的比较。</p>
<p>在case语句下，比较进入分支时，本身带有优先级（即从第一种情况到default），因而这本身综合器会综合一个组合逻辑的优先级编码器电路。由于onehot编码本身不存在优先级，每一个case在逻辑上是并行，这是作者唯一推荐使用full_case 和 parallel_case 语句（告诉仿真器 1. 已经穷尽了所有case，不要生成锁存器 2.消除优先级编码器电路）</p>
<p>This is the only coding style where I recommend using full_case and parallel_case statements. The parallel case statement tells the synthesis tool to not build a priority encoder even though in theory, more than one of the state bits could be set (as engineers, we know that this is a onehot FSM and that only one bit can be set so no priority encoder is required). The value of the full_case statement is still in question.</p>
<p>Note：多个输出onehot编码，优先编码器</p>
<blockquote>
<p><a href="http://www.cburch.com/logisim/docs/2.3.0/libs/plexers/priencod.html">http://www.cburch.com/logisim/docs/2.3.0/libs/plexers/priencod.html</a></p>
</blockquote>
<p>关于parallel_case和full_case的使用</p>
<blockquote>
<p><a href="https://blog.csdn.net/teenagerold/article/details/78022636?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">https://blog.csdn.net/teenagerold/article/details/78022636?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/childbor/article/details/78633541?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242">https://blog.csdn.net/childbor/article/details/78633541?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242</a></p>
</blockquote>
<h3 id="8-Registered-FSM-Output-Good-style"><a href="#8-Registered-FSM-Output-Good-style" class="headerlink" title="8 Registered FSM Output. (Good style)"></a>8 Registered FSM Output. (Good style)</h3><p>在输出级加一个register可以保证输出没有glitch，优化综合结果。</p>
<p>Registering the outputs of an FSM design insures that the outputs are <strong>glitch-free</strong> and frequently improves synthesis results by standardizing the output and input delay constraints of synthesized modules.</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/5.registeredFSM.png" alt="Figure 6.Registered FSM"></p>
<h3 id="9-System-Verilog-Enhancement"><a href="#9-System-Verilog-Enhancement" class="headerlink" title="9 System Verilog Enhancement"></a>9 System Verilog Enhancement</h3>]]></content>
      <categories>
        <category>FSM_verilog</category>
      </categories>
      <tags>
        <tag>FSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SV_1.1 Data Type</title>
    <url>/2021/04/02/System_Verilog/SV_1.1%20Data%20Type/</url>
    <content><![CDATA[<p>Source from :</p>
<ol>
<li><p>《芯片验证漫游指南》- Page 108-111</p>
</li>
<li><p>《System Verilog验证》- Chapter 2</p>
</li>
</ol>
<h2 id="1-数据类型-内建数据类型："><a href="#1-数据类型-内建数据类型：" class="headerlink" title="1. 数据类型-内建数据类型："></a>1. 数据类型-内建数据类型：</h2><h3 id="1-1-logic-类型"><a href="#1-1-logic-类型" class="headerlink" title="1.1 logic 类型"></a>1.1 logic 类型</h3><p>SV中引入一个新的数据类型logic（还有net &amp; wire）</p>
<p>SV作为侧重于验证的语言，并不关切logic对应的逻辑应该被综合为寄存器还是线网，因为logic被使用的场景如果是验证环境，呢么它只会作为单纯的变量进行赋值操作，而这些变量也只属于软件环境构建。</p>
<p>原因：方便验证人员节省考虑是线网还是寄存器变量的时间和精力。</p>
<p>Note：</p>
<ul>
<li>logic 声明的变量可以被连续赋值，门单位和模块所驱动</li>
<li>使用net类型的地方均可以使用logic，但是要求logic不能有通过多个结构性的驱动（如双向总线建模），此时需要用net类型。</li>
</ul>
<p>Note:</p>
<ul>
<li><p>可以将所有类型（reg&amp;wire）都定义成logic，在多个驱动的地方会发生编译错误（编译器期待为wire类型）</p>
</li>
<li><p>logic 是四值逻辑（0，1，X，Z）</p>
</li>
</ul>
<h3 id="1-2-双状态数据类型"><a href="#1-2-双状态数据类型" class="headerlink" title="1.2 双状态数据类型"></a>1.2 双状态数据类型</h3><p>引入二状态数据类型（0 or 1）的原因：</p>
<ol>
<li>软硬scope区分：</li>
</ol>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/1.png" alt="Figure 1.二值逻辑"></p>
<ol start="2">
<li>仿真器的内存使用减少，提高仿真器的精度。</li>
</ol>
<p>四值逻辑类型，二值逻辑类型变量划分</p>
<ul>
<li><p>四值：integer（32位）, logic, reg, net-type(wire)</p>
</li>
<li><p>二值：byte (类比C的char，8位), shortint（16位）, int（32位）, longint（64位）, bit (1 位)</p>
</li>
</ul>
<p>有符号类型，无符号类型变量划分</p>
<ul>
<li><p>有符号类型：byte，shortint，int，longint，integer</p>
</li>
<li><p>无符号类型：bit, logic, reg, net-type(wire &amp; tri)</p>
</li>
</ul>
<p>Case：</p>
<ol>
<li>不同数据类型的变量之间的赋值：</li>
</ol>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/2.png"></p>
<p>ans：128，128，-128</p>
<ol start="2">
<li>不同位宽的数据转换 是 补0还是补1：</li>
</ol>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/3.png"></p>
<p>ans：有符号数转换，先拓展了一位符号位。<code>h180。           无符号数转化，拓展补0。 </code>h080。</p>
<p>细节：在双状态变量连接DUT，尤其被测设计输出产生X or Z时候，这些值会被转换成0或者1，而测试代码可能永远检测不到X or Z。使用（$isunkown）操作符可以检查在任意位出现X还是Z时候，返回1。</p>
<p>数据转换：编码时一定要注意操作符左右两侧的符号类型是否一致，如果不一致，应该首先将其转换为同一类型再转换。</p>
<ul>
<li>静态转换<br>需要转换的表达式前加上单引号即可。编译时候检查。</li>
<li>动态转换</li>
</ul>
<p>$cast(tgt,src)。 仿真时候检查。</p>
<p>静态转化或者动态转换都需要操作符或者系统函数的介入，称为显式转换。</p>
<p>下面介绍隐式转换：</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/4.png" alt="Figure 4.隐式转换"></p>
<p>四值逻辑转换成二值逻辑。（<strong>X只会变成0</strong>）：ans：111x，110</p>
<p>在操作不同变量时，除去变量的数值：需要考虑变量的以下性质：</p>
<ul>
<li>逻辑数值类型</li>
<li>符号类型</li>
<li>矢量位宽</li>
</ul>
<h2 id="2-定宽数组"><a href="#2-定宽数组" class="headerlink" title="2. 定宽数组"></a>2. 定宽数组</h2><h3 id="2-1-数组声明-amp-初始化："><a href="#2-1-数组声明-amp-初始化：" class="headerlink" title="2.1 数组声明&amp;初始化："></a>2.1 数组声明&amp;初始化：</h3><pre><code>int a [16] 
int a [0:15]
int array [8][4] ; // 创建一个8行4列的矩阵
array [7][3] = 1;  // 设置最后一个元素
</code></pre>
<p>Note：</p>
<ul>
<li><p>当你的程序试图读取一个超越定义范围的地址中读取数据，SV则会返回<strong>数组元素类型</strong>的缺省值。对于四状态类型的数组如logic，返回的是X；对于双状态类型例如int or bit 则返回0。</p>
</li>
<li><p>线网在没有驱动的时候输出是Z</p>
</li>
</ul>
<p>Note: </p>
<p>数组声明放在数组名字右边。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/5.png" alt="Figure 5. 数组初始化"></p>
<p>Note: </p>
<ol>
<li><p><code>&#123;&#125; 赋值；Name = </code>{0, 1, 2, 3};</p>
</li>
<li><p>N {1} : 重复符号</p>
</li>
</ol>
<h3 id="2-2-存储空间考量（合并与非合并）"><a href="#2-2-存储空间考量（合并与非合并）" class="headerlink" title="2.2 存储空间考量（合并与非合并）"></a>2.2 存储空间考量（合并与非合并）</h3><p>SV仿真器在存放数组元素时候时，使用32bit（4 byte=1 word）的字边界。因此byte，shortint，int都是存在一个字。longint放在两个字。</p>
<ul>
<li><p>合并：</p>
<p>  bit [3][7:0] b_pack; // 维度声明放在了变量名左边，占用1个word</p>
</li>
<li><p>非合并：</p>
<p>  bit [7:0] b_unpack [3] // 如下，占用3个word.</p>
</li>
</ul>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/6.png" alt="Figure 6.非合并space"></p>
<p>exercise</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/7.png" alt="Figure 7."></p>
<p>ans: logic 是4值逻辑，软件上需要两位来存储。</p>
<p>第一种是合并存储：3<em>8</em>2/32=1.5  需要两个word</p>
<p>第二种是非合并存储：每一个word 足够存储一个数值，需要三个word。</p>
<h3 id="2-3-基本数组操作"><a href="#2-3-基本数组操作" class="headerlink" title="2.3 基本数组操作"></a>2.3 基本数组操作</h3><h4 id="2-3-1-for和foreach循环"><a href="#2-3-1-for和foreach循环" class="headerlink" title="2.3.1 for和foreach循环"></a>2.3.1 for和foreach循环</h4><pre><code>$size(Array Name); 返回数组的宽度
</code></pre>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/8.png" alt="Figure 8. Foreach使用范例"></p>
<p>foreach 赋值多维数组的的语法，不是 [i][j]，而是[i,j]。</p>
<pre><code>foreach (md[i,j])
$display (&quot;md[%0d][%0d]=%0d&quot;, i , j, md[i][j]);
</code></pre>
<h4 id="2-3-2-赋值与比较"><a href="#2-3-2-赋值与比较" class="headerlink" title="2.3.2 赋值与比较"></a>2.3.2 赋值与比较</h4><p>赋值可以直接采用 = 传递</p>
<p>比较可以直接采用 == 进行两个数组的比较，不需要用for比较每个元素</p>
<p>还可以进行数组片段比较：</p>
<pre><code>$display(&quot;src[1:4] %s dst[1:4]&quot;, (src[1:4] == dst[1:4)? &quot;==&quot; : &quot;!=&quot;);
</code></pre>
<h3 id="2-4-合并数组与非合并数组"><a href="#2-4-合并数组与非合并数组" class="headerlink" title="2.4 合并数组与非合并数组"></a>2.4 合并数组与非合并数组</h3><p>合并数组的声明：必须是[msb:lsb] 不能是[size]</p>
<p>使用合并数组后，可以单独访问数组中的一部分。</p>
<p>关于合并数组的选择：</p>
<ul>
<li><p>需要以Byte或者word为单位进行对存储单位进行重复读写的需求</p>
</li>
<li><p>当需要等待数组的值的变化（敏感列表）必须使用合并数组。</p>
</li>
</ul>
<h2 id="3-动态数组"><a href="#3-动态数组" class="headerlink" title="3. 动态数组"></a>3. 动态数组</h2><p>数组的大小可以灵活调整宽度，可在仿真时灵活调节数组的大小即存储量。可以开辟新的存储空间。</p>
<p>Dyn数组的各种操作，赋值，拓展，删除。</p>
<p>int dyn[]</p>
<p>dyn= new [宽度]</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/9.png" alt="Figure 9. 动态数组使用"></p>
<p>可以用一个常量数组给动态数组赋值。</p>
<p>int 的默认值是0， integer的默认值是1。</p>
<h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><p>结合了链表和数组；可以在任何一个地方添加，删除元素并且可以通过索引的方式实现对任一元素的访问。</p>
<p>优点：执行插入元素这种操作时，使用队列比使用动态数组带来的性能损失少（动态数组需要开辟新的存储空间，并复制原有的数组的数据）</p>
<p>队列的声明：</p>
<ol>
<li><p>Name[$]={0,1} // 不需要在前面加“ ` ”</p>
</li>
<li><p>name.insert(index, 内容) //在队列的某一位前插入一位或者一个队列</p>
</li>
<li><p>name.delete(index) //删除队列某一位数据</p>
</li>
</ol>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/10.png" alt="Figure 10.队列使用"></p>
<pre><code> push_back() and pop_front() 的结合实现一个FIFO的用法
</code></pre>
<p>Note: </p>
<pre><code>q.size()         //查找q的队列长度, 
[$:2]: [0:2]         //使用$可以表示最大值或者最小值：
[2:$]: [2:最大值]
j =q[$]  //队列的最高位赋给j
</code></pre>
<h2 id="5-关联数组"><a href="#5-关联数组" class="headerlink" title="5. 关联数组"></a>5. 关联数组</h2><p>如果需要一个超大容量的数组（模拟存储器），若利用动态数组建立，一旦创建时就被固定下来，对于超大容量的数组则是浪费资源。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/SV/1.1_data_type/11.png" alt="Figure 11.关联数组使用"></p>
<h2 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6. 结构体"></a>6. 结构体</h2><p>verilog中无数据结构，SV可以使用struct语句创建结构，跟C语言相似。</p>
]]></content>
      <categories>
        <category>SV</category>
      </categories>
      <tags>
        <tag>SV</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog Ch1&amp;2</title>
    <url>/2021/04/02/Verilog/Verilog%20Ch1&amp;2/</url>
    <content><![CDATA[<p>In this chapter, we would focus on fundamentals and core concepts of Verilog HDL. 在这一章中，主要介绍一些概念和Verlog HDL的基础知识。</p>
<h3 id="0-模块概念："><a href="#0-模块概念：" class="headerlink" title="0.模块概念："></a>0.模块概念：</h3><ul>
<li><p>软核 Soft core:<br>  一般指经过功能验证，可综合的Verilog HDL（VHDL）模型.</p>
</li>
<li><p>固核 Firm core:<br>  通知指在ASIC or FPGA 器件上，经过综合验证的电路网表文件。</p>
</li>
<li><p>硬核 Hard core:<br>  在ASIC器件上，经过验证正确的的电路结构版图掩膜。</p>
</li>
</ul>
<h3 id="1-Verilog-HDL-基础"><a href="#1-Verilog-HDL-基础" class="headerlink" title="1.Verilog HDL 基础"></a>1.Verilog HDL 基础</h3><ul>
<li>数值状态</li>
</ul>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/1.%20FSM%E7%B1%BB%E5%9E%8B.png" alt="Figure 1.Vaule_conditions"></p>
<ul>
<li>位制：二进制 b； 八进制: o；十进制：d；十六进制：h</li>
<li>整数表示 8‘b0000_0001。 位数‘位制‘数字</li>
</ul>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><ul>
<li>分类：wire（tri三态门，tri0下拉电阻，tri1上拉电阻），reg，RAM</li>
<li>reg：对应硬件电路元件具有状态保持作用；触发器，锁存器</li>
<li>RAM：类似于二维数组的定义方式。 reg[7:0] mem1[255:0] //定义256个8位寄存器的mem。</li>
</ul>
<p>抽象数据类型：</p>
<ul>
<li>整型 integer，时间 time，实型 real ，参数型parameter.</li>
<li>integer index //定义32位有符号数</li>
<li>time a; // 定义两个64位的时间型变量。<br>主要用于对模拟时间的存储和计算处理，常与$time 一起使用</li>
<li>real stime; // 定义一个实数型数据（浮点型），常用于延迟时间的计算</li>
<li>parameter length=32, // 常量，在仿真之前就被复制，提高程序可读性。</li>
</ul>
<p>运算符：<br><img src="https://github.com/XuLixing/blog_images/raw/main/Learning_Notes/FSM/images/2.%20code%20style.png" alt="Figure 2.opeartors"></p>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a><em>Note</em>:</h4><p>赋值语句下，结果的长度是由操作左端目标长度决定。取低N位，不够补0。</p>
<h3 id="3-条件运算符"><a href="#3-条件运算符" class="headerlink" title="3. 条件运算符"></a>3. 条件运算符</h3><p>example: (!sel)?in1:in2;</p>
<h3 id="4-连接和复制运算符"><a href="#4-连接和复制运算符" class="headerlink" title="4. 连接和复制运算符"></a>4. 连接和复制运算符</h3><p><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_1%262/images_1%262/%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%8D%E5%88%B6.png" alt="Figure 3.连接"></p>
<h3 id="5-模块的基本概念"><a href="#5-模块的基本概念" class="headerlink" title="5. 模块的基本概念"></a>5. 模块的基本概念</h3><p>Module是verilog HDL的基本单元</p>
<blockquote>
<p>组成：</p>
</blockquote>
<ul>
<li>开始：NAME module；- endmodule</li>
<li>端口定义：input output （模块引用具体）</li>
<li>数据类型定义： wire，reg，memory，parameter</li>
<li>逻辑功能描述：initial，always，assign，function，task</li>
</ul>
]]></content>
      <categories>
        <category>verilog</category>
      </categories>
      <tags>
        <tag>verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog Ch3</title>
    <url>/2021/04/02/Verilog/Verilog%20Ch3/</url>
    <content><![CDATA[<h3 id="3-1-数据流建模"><a href="#3-1-数据流建模" class="headerlink" title="3.1 数据流建模"></a>3.1 数据流建模</h3><h3 id="3-11-连续赋值语句"><a href="#3-11-连续赋值语句" class="headerlink" title="3.11 连续赋值语句"></a>3.11 连续赋值语句</h3><ul>
<li>标量，如wire a,b;</li>
<li>向量，如wire [3:0] a, b;</li>
</ul>
<p>Note：</p>
<blockquote>
<ol>
<li>Assign 类型 需要用 ‘=’</li>
<li>变量需要wire类型  </li>
<li>并行计算，没有顺序</li>
</ol>
</blockquote>
<h3 id="3-2-行为级建模"><a href="#3-2-行为级建模" class="headerlink" title="3.2 行为级建模"></a>3.2 行为级建模</h3><h3 id="3-2-1-过程语句"><a href="#3-2-1-过程语句" class="headerlink" title="3.2.1 过程语句"></a>3.2.1 过程语句</h3><p>A）initial 过程语句</p>
<p>initial 下顺序赋值，添加<code>[#100]</code>等表达式可以增加延迟。</p>
<p>格式：</p>
<pre><code>initial
    
    begin
    
    end
</code></pre>
<p>B）always 过程语句:</p>
<p>always @(敏感列表)</p>
<p>code example：</p>
<pre><code>always @()

    case()

    endcase
</code></pre>
<pre><code>always @( )

    begin

    end
</code></pre>
<p>Note:</p>
<blockquote>
<ol>
<li>在过程语句（initial 和 always）中，被赋值信号必须被定义为 reg 型。</li>
<li>采用过程对组合逻辑电路进行描述时：全部输入信号需要列入敏感列表。</li>
<li>采用过程对时序逻辑电路进行描述时：需要把时间信号和部分输入信号列入。</li>
</ol>
</blockquote>
<h3 id="3-2-2-语句块"><a href="#3-2-2-语句块" class="headerlink" title="3.2.2 语句块"></a>3.2.2 语句块</h3><p>A）begin-end：语句内部按照顺序执行，可以用于可综合电路程序和仿真测试程序。</p>
<p>B) fork-join: 语句内部按照按照并行方式，不可以用于可综合电路，只能用于仿真程序测试。</p>
<p>比较：<br><a href="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/1.%E6%AF%94%E8%BE%83.png">Figure 1.比较</a></p>
<p>###3.2.3 过程赋值语句</p>
<p><em>阻塞赋值语句和非阻塞赋值语句</em></p>
<ul>
<li>阻塞赋值语句“=” 有如下特点：<ol>
<li>串行语句块中，各条阻塞赋值语句将按照先后排列顺序一次执行。<br>并行语句块中，各条阻塞赋值语句同时执行，没有顺序</li>
<li>执行阻塞赋值语句的顺序是：先计算等号右端的表达式，然后立刻赋值给左边的变量，没有延时。</li>
</ol>
</li>
<li>非阻塞赋值语句“&lt;=” 有如下特点：<ol>
<li>串行语句块，各条非阻塞赋值语句的执行没有先后顺序之分。前面的语句不会影响后边语句的执行。各条语句并行执行。</li>
<li>执行非阻塞赋值语句的顺序是，先计算右端表达式的值，然后等到延时时间结束，再将计算的值付给左边的变量。</li>
</ol>
</li>
</ul>
<p>Note:<br>    需要掌握，阻塞和非阻塞电路对应verilog程序综合的电路的情况。<br><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/2.%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E.png" alt="Figure 2.阻塞非阻塞"></p>
<p>###3.2.4 过程连续赋值语句<br>过程性连续赋值语句有两种类型：赋值，重新赋值( assign, deasign) 和 强制、释放（force，release）</p>
<h3 id="3-2-5-条件分支语句"><a href="#3-2-5-条件分支语句" class="headerlink" title="3.2.5 条件分支语句"></a>3.2.5 条件分支语句</h3><p>Verilog HDL的条件分支语句有两种，If条件语句和case条件分支语句</p>
<ol>
<li>if - else</li>
<li>case  条件分支。<br>容易实现多路分支选择控制的语句，更加直观和方便。</li>
</ol>
<pre><code>    case
    0 : 
    1 :
    ...: // 穷尽每一种情况
    default: 
    endcase
</code></pre>
<p><img src="https://github.com/XuLixing/blog_images/blob/main/Verilog_Learning/Verilog_chapter_3/images_3/3.%E6%95%B0%E7%A0%81%E7%AE%A1%E8%AF%91%E7%A0%81.png" alt="Figure 4.数码管译码"></p>
<p>Note : 使用case语句时，case应该包含所有的状态，如果没有包含全，则缺少项回产生锁存器！！！ 这是不允许的在同步时许电路设计中。</p>
<h3 id="3-2-6-循环语句"><a href="#3-2-6-循环语句" class="headerlink" title="3.2.6 循环语句"></a>3.2.6 循环语句</h3><ol>
<li><p>forever<br>永久循环。在永久循环内不包含任何条件表达式，只执行无限的循环，指导遇到系统任务¥finish为止。如果需要从forever循环汇总推出，则可以使用disable语句。<br><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/3.forever.png" alt="Figure 4.forever"></p>
</li>
<li><p>repeat<br>所引导的循环语句执行固定次数的循环。<br><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/5.repeat.png" alt="Figure 5.repeat"></p>
</li>
<li><p>while<br>仅有在while （） 括号内表达式为真才执行。<br><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/6.while.png" alt="Figure 6.while"></p>
</li>
<li><p>for<br><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/7.for.png" alt="Figure 7.for"></p>
</li>
</ol>
<h3 id="3-3-结构化建模"><a href="#3-3-结构化建模" class="headerlink" title="3.3 结构化建模"></a>3.3 结构化建模</h3><h4 id="3-3-1-模块级建模"><a href="#3-3-1-模块级建模" class="headerlink" title="3.3.1 模块级建模"></a>3.3.1 模块级建模</h4><ol>
<li><p>模块调用方式<br>在Verilog HDL中，模块可以被任何模块调用，这种调用实际上是将模块所描述的电路复制并连接。模块调用的基本语法格式是：<br>模块名 &lt;参数值列表&gt; 实例名 （端口名列表）：<br><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/8.%E7%BB%93%E6%9E%84%E5%8C%96.png" alt="Figure 8.实例化"></p>
<p> Note：</p>
<p> A. 在同一个模块中当前模块被调用了几次，则需要用不同的实例名加以标明。</p>
<p> B. 当需要多次调用，可以采用 阵列调用的方式对模块进行调用。<br> （下面例子是对应位相与）</p>
</li>
</ol>
<p> <img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/9.%E7%BB%93%E6%9E%84%E5%8C%96.png" alt="Figure 9.多次实例化"></p>
<ol start="2">
<li>模块端口对应方式</li>
</ol>
<ul>
<li>端口位置对应方式：调用时，端口一定要严格按照端口定义顺序。</li>
<li>端口名对应方式：</li>
</ul>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/Verilog_Learning/Verilog_chapter_3/images_3/10.%20%E7%BB%93%E6%9E%84%E5%8C%96.png" alt="Figure 10.端口对应方式"></p>
<pre><code> .clk(clock), （）内是模块定义的变量，clk是调用模块的变量。
</code></pre>
<ul>
<li>不同端口位宽的匹配：从低位开始取。</li>
</ul>
<ol start="3">
<li> 模块参考值<br>有两种途径可以改变模块实例的参考值，分别是使用带有参数的模块实例语句修改参数值和使用定义参数语句（defparam）</li>
</ol>
<p>3.3.2 门级建模</p>
<p>3.3.3 开关级建模</p>
]]></content>
      <categories>
        <category>verilog</category>
      </categories>
      <tags>
        <tag>verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>ASIC Design Flow 设计流程</title>
    <url>/2021/03/29/ASIC/ASIC_design_flow/</url>
    <content><![CDATA[<p>An ASIC (application-specific integrated circuit) is an IC customized for a particular use, rather than intended for general-purpose use</p>
<h2 id="0-ASIC-Overview"><a href="#0-ASIC-Overview" class="headerlink" title="0.ASIC Overview:"></a>0.ASIC Overview:</h2><h3 id="0-1-概况"><a href="#0-1-概况" class="headerlink" title="0.1 概况"></a>0.1 概况</h3><p>芯片结构基于基本单元，芯片内部网络网格化，等高单元在芯片内部整齐排列</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/1.VLSI_overviwe.png" alt="Figure 1.ASIC概况"></p>
<h3 id="0-2-标准单元库："><a href="#0-2-标准单元库：" class="headerlink" title="0.2 标准单元库："></a>0.2 标准单元库：</h3><ul>
<li>预先设计好的单元组成设计库</li>
<li>综合工具自动选取单元构建电路实现逻辑 ——— link2综合原理</li>
</ul>
<h3 id="0-3-ASIC的优势："><a href="#0-3-ASIC的优势：" class="headerlink" title="0.3 ASIC的优势："></a>0.3 ASIC的优势：</h3><p>相比于FPGA：平均而言，相同功能的电路， FPGA芯片所需的硅片面积是ASIC的35倍。 FPFA芯片的关键路径延时是ASIC的3.5倍。 FPGA芯片的动态功耗是ASIC的14倍。</p>
<h3 id="0-4-电路描述与设计过程："><a href="#0-4-电路描述与设计过程：" class="headerlink" title="0.4 电路描述与设计过程："></a>0.4 电路描述与设计过程：</h3><p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/2.%E7%94%B5%E8%B7%AF%E6%8F%8F%E8%BF%B0%E6%96%B9%E5%BC%8F.png" alt="Figure 2.不同层次描述"></p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/3.%E7%94%B5%E8%B7%AF%E6%8F%8F%E8%BF%B0%E6%8A%BD%E8%B1%A1.png" alt="Figure 3.前段/后端"></p>
<h2 id="1-ASIC设计流程"><a href="#1-ASIC设计流程" class="headerlink" title="1. ASIC设计流程"></a>1. ASIC设计流程</h2><h3 id="1-1-确定体系结构："><a href="#1-1-确定体系结构：" class="headerlink" title="1.1 确定体系结构："></a>1.1 确定体系结构：</h3><blockquote>
<p>寄存器组有多少组，数量多少</p>
</blockquote>
<blockquote>
<p>指令集：基本指令以及指令编码</p>
</blockquote>
<h3 id="1-2-体系微架构："><a href="#1-2-体系微架构：" class="headerlink" title="1.2 体系微架构："></a>1.2 体系微架构：</h3><blockquote>
<p>A. 多周期流水线结构框图</p>
</blockquote>
<blockquote>
<p>B. 控制信号逻辑，控制状态机，状态转移图</p>
</blockquote>
<h3 id="1-3-逻辑设计："><a href="#1-3-逻辑设计：" class="headerlink" title="1.3 逻辑设计："></a>1.3 逻辑设计：</h3><blockquote>
<p>A. 顶层接口：引脚数量，名称定义</p>
</blockquote>
<blockquote>
<p>B. 确定设计层次：控制通路和数据通路确定，电路组，标准单元库等等</p>
</blockquote>
<blockquote>
<p>C. 建立电路文档，包含行为级信息。使用硬件描述语言描述电路，并综合生成逻辑网表</p>
</blockquote>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/4.%20%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1.png" alt="Figure 4.控制&amp;数据通路"></p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/5.%20%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1.png" alt="Figure 5.硬件的层次化描述"></p>
<h3 id="1-4-物理设计："><a href="#1-4-物理设计：" class="headerlink" title="1.4 物理设计："></a>1.4 物理设计：</h3><blockquote>
<p>A：导入标准单元库（等高）</p>
<p>B：Floorplan 平面规划</p>
<p>C：引脚布局</p>
</blockquote>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/6.%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1.png" alt="Figure 6.物理设计"></p>
<h3 id="1-5-设计验证："><a href="#1-5-设计验证：" class="headerlink" title="1.5 设计验证："></a>1.5 设计验证：</h3><blockquote>
<p>确保功能正确</p>
</blockquote>
<blockquote>
<p>确保时钟频率满足要求</p>
</blockquote>
<blockquote>
<p>确保功耗和面积满足要求</p>
</blockquote>
<blockquote>
<p>确保流片成功</p>
</blockquote>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/7.%E8%AE%BE%E8%AE%A1%E9%AA%8C%E8%AF%81.png" alt="Figure 7.设计过程"></p>
<h3 id="1-6-流片-（tape-out）"><a href="#1-6-流片-（tape-out）" class="headerlink" title="1.6 流片 （tape out）"></a>1.6 流片 （tape out）</h3><p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/11.%E6%B5%81%E7%89%87.png" alt="Figure 8.MPW 服务"></p>
<h3 id="1-7-封装（日月光）"><a href="#1-7-封装（日月光）" class="headerlink" title="1.7 封装（日月光）"></a>1.7 封装（日月光）</h3><p>封装有多种类型。引脚数量，封装材料，封装方式不同。</p>
<h3 id="1-9-测试（华天）"><a href="#1-9-测试（华天）" class="headerlink" title="1.9 测试（华天）"></a>1.9 测试（华天）</h3><h2 id="2-ASIC设计过程及其工具"><a href="#2-ASIC设计过程及其工具" class="headerlink" title="2 ASIC设计过程及其工具"></a>2 ASIC设计过程及其工具</h2><h3 id="2-1-数字ASIC设计可分为两个阶段，均包含设计与验证。"><a href="#2-1-数字ASIC设计可分为两个阶段，均包含设计与验证。" class="headerlink" title="2.1 数字ASIC设计可分为两个阶段，均包含设计与验证。"></a>2.1 数字ASIC设计可分为两个阶段，均包含设计与验证。</h3><p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/8.ASIC%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png" alt="Figure 9.ASIC粗略可分为两个阶段"></p>
<h3 id="2-2-基于Synosys平台各项工具及其功能："><a href="#2-2-基于Synosys平台各项工具及其功能：" class="headerlink" title="2.2 基于Synosys平台各项工具及其功能："></a>2.2 基于Synosys平台各项工具及其功能：</h3><p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/9.ASIC%E5%B7%A5%E5%85%B7.png" alt="Figure 10.ASIC设计工具"></p>
<p>设计过程中：RTL代码是通用代码，但是门级网表和版图必须是确定工艺的网表和版图。工艺对芯片的速度、面积和功耗有决定性的作用。</p>
<p><img src="https://github.com/XuLixing/blog_images/raw/main/VLSI_Design/1.VLSI_design_flow/images/10.%E5%B7%A5%E8%89%BA%E7%BD%91%E8%A1%A8%E5%92%8C%E7%89%88%E5%9B%BE.png" alt="Figure 11.逻辑/物理综合的原理"></p>
<p>————————————————————————</p>
<h2 id="3-Appendix"><a href="#3-Appendix" class="headerlink" title="3 Appendix"></a>3 Appendix</h2><p>Detailed Design Flow：(Based on Synopsys)</p>
<ol>
<li>将已经在 FPGA 上验证过的代码(Verilog)修改为不依赖于 FPGA 资源 的 RTL 代码。</li>
<li>使用 VCS 对 RTL 代码进行输入输出关系仿真，进行功能验证。</li>
<li>使用 Design Compiler(DC)对 RTL 代码进行逻辑综合，获得 DC 网<br>表。</li>
<li>使用 Formality 对 RTL 代码和 DC 网表进行形式验证，验证两者的结构 一致性。</li>
<li>使用 VCS 对 DC 网表进行输入输出关系仿真，对比 RTL 仿真的结果， 验证两者的功能一致性。</li>
<li>使用 IC Compiler(ICC)对 DC 网表进行物理综合，获得 ICC 网表和 版图。</li>
<li>使用 Calibre 对版图进行设计天线规则检查，规则检查(DRC)和原理 图版图一致性检查(LVS)。</li>
<li>使用 Formality 对 DC 网表和 ICC 网表进行形式验证，验证两者的结构 一致性。</li>
<li>使用 StarRC 对版图进行电容电阻参数提取，获得 RC 参数，进一步获 得各网线的延迟信息。此将此延迟信息并反标至 ICC 网表。</li>
<li>使用 PrimeTime 对反标后的 ICC 网表进行时序分析，并导出 sdf 延时文 件用于 VCS 后仿。</li>
<li>使用 VCS 对反标后的 ICC 网表进行输入输出关系仿真，对比 RTL 仿真 的结果，验证两者的功能一致性。</li>
<li>获得 GDSII 文档。</li>
</ol>
]]></content>
      <categories>
        <category>ASIC_Design</category>
      </categories>
      <tags>
        <tag>ASIC design</tag>
      </tags>
  </entry>
</search>
